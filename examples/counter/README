In this example we evaluate various ways of implementing a program that
launches N threads, which each execute a critical section X times,
such that the total number of critical section executions equals:
X/N = 100,000,000

make
builds a version for 5, 50 and 500 threads for each of the locking schemes:
a) pthreads uses pthreads directly: counter_pthreads{5,50,500}
b) std uses std::mutex and std::lock_guard for locking: counter_std{5,50,500}
c) qd uses QD locking as provided by this library: counter_qd{5,50,500}

You can use the following command to view output including runtimes:
for counter in *5 *50 *500; do ./$counter; echo; done

The critical section is implemented in cs.cpp.

counter_pthreads.cpp - pthreads-only implementation
counter_std.cpp - std::mutex based implementation
counter_qd.cpp - using the qd locks provided by this library

make atomics
additionally builds versions using atomic instructions instead of locks.
The atomic critical section is implemented in cs_atomic.cpp.

